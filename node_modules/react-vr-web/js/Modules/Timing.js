/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

const IDLE_CALLBACK_THRESHOLD = 1; // Minimum idle execution time of 1ms

/**
 * The Timing Module allows the browser client to synchronize React timers with
 * the frame rate of the client.
 * This module is internal to the runtime and not designed to be called directly
 * Timers to the React code are distributed by event messages sent via the WebWorker
 * using the React Native Context
 * @class Timing
 * @extends Module
 */

import Module from './Module';

// Defines Timing object, maintains internal timer array.
// Relies on rncx. Includes createTimer/deleteTimer methods, and frame() processing
// method for timers. Timers are identified by id. Timers are called once per frame,
// once their scheduleing time has reached, them removed if not repeating.
// Called through _rnctx.callFunction("JSTimersExecution", "callTimers")
// ...is the intent that it delegates to native on android?
export default class Timing extends Module {
  /**
   * Constructs a Timing Module with a React Native Context
   * The Context is used to trigger the registered timer callbacks on each frame
   */
  constructor(rnctx) {
    super('Timing');
    this._timers = {};
    this._rnctx = rnctx;
    this._sendIdleEvents = false;
    // Ideal frame size, in milliseconds
    this._targetFrameDuration = 1000.0 / (rnctx.isLowLatency ? 90.0 : 60.0);
  }

  /**
   * Creates a new timer, and associates it with a specific callback.
   * @param callbackID - The callback triggered when this timer completes
   * @param duration - The time before the timer completes, in milliseconds
   * @param jsSchedulingTime - The baseline time to measure against
   * @param repeats - Whether the timer repeats, or runs once
   */
  createTimer(callbackID, duration, jsSchedulingTime, repeats) {
    const currentTimeMillis = Date.now();
    const currentDateNowTimeMillis = jsSchedulingTime + (1000 / 60);
    const adjustedDuration =
      Math.max(0.0, jsSchedulingTime - currentDateNowTimeMillis + duration);
    const initialTargetTime = currentTimeMillis + adjustedDuration;
    this._timers[callbackID] = {
      callbackID: callbackID,
      duration: duration,
      jsSchedulingTime: initialTargetTime,
      repeats: repeats,
    };
  }

  /**
   * Removes the timer associated with a specific callback
   * @paramID - callbackID associated with React
   */
  deleteTimer(callbackID) {
    delete this._timers[callbackID];
  }

  /**
   * Enable or disable the sending of idle events on each frame
   * When these are sent, they trigger requestIdleCallback callbacks on the
   * React side.
   * @param sendIdle - boolean flag to enable or disable sending idle events
   */
  setSendIdleEvents(sendIdle) {
    this._sendIdleEvents = sendIdle;
  }

  /**
   * Update all timers, triggering callbacks for timers that have completed,
   * and cleaning up those that are not repeating.
   */
  frame(frameStart) {
    const toRemove = [];
    const timers = [];
    const time = Date.now();
    for (let timer in this._timers) {
      const t = this._timers[timer];
      if (t.jsSchedulingTime <= time) {
        timers.push(this._timers[timer].callbackID);
        if (t.repeats) {
          t.jsSchedulingTime += t.duration;
        } else {
          toRemove.push(timer);
        }
      }
    }
    // timer information is distributed in a single message with mulitiple params
    // which minimizes the bridge traffic when many timers are used
    if (timers.length) {
      this._rnctx.callFunction('JSTimersExecution', 'callTimers', [timers]);
    }

    for (let timer in toRemove) {
      delete this._timers[toRemove[timer]];
    }
  }

  /**
   * Check to see if there's enough time left in the frame execution to run
   * idle callbacks. If there is, trigger them across the bridge.
   * @param frameStart - A timestamp representing the start time of this frame,
   *   used to determine whether there is any idle time left
   */
  idle(frameStart) {
    if (!this._sendIdleEvents) {
      return;
    }
    const now = window.performance ? performance.now() : Date.now();
    const frameElapsed = now - frameStart;
    if (this._targetFrameDuration - frameElapsed >= IDLE_CALLBACK_THRESHOLD) {
      this._rnctx.callFunction(
        'JSTimersExecution',
        'callIdleCallbacks',
        [Date.now() - frameElapsed]
      )
    }
  }
}

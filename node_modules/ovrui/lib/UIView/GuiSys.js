/*
 * Copyright (c) 2016-present, Oculus, LLC
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = GuiSys;

var _ThreeShim = require('../ThreeShim');

var _ThreeShim2 = _interopRequireDefault(_ThreeShim);

var _InputControls = require('../Inputs/InputControls');

var _InputControls2 = _interopRequireDefault(_InputControls);

var _GamepadInputs = require('../Inputs/GamepadInputs');

var _GamepadInputs2 = _interopRequireDefault(_GamepadInputs);

var _KeyboardInputs = require('../Inputs/KeyboardInputs');

var _KeyboardInputs2 = _interopRequireDefault(_KeyboardInputs);

var _MouseInputs = require('../Inputs/MouseInputs');

var _MouseInputs2 = _interopRequireDefault(_MouseInputs);

var _TouchInputs = require('../Inputs/TouchInputs');

var _TouchInputs2 = _interopRequireDefault(_TouchInputs);

var _SDFFont = require('../SDFFont/SDFFont');

var _GuiSysEvent = require('./GuiSysEvent');

var _UIViewUtil = require('./UIViewUtil');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_Z_OFFSET_SCALE = 0.001; /*
                                     * Copyright (c) 2016-present, Oculus, LLC
                                     * All rights reserved.
                                     *
                                     * This source code is licensed under the license found in the LICENSE file in
                                     * the root directory of this source tree.
                                     */

/*
 * GuiSys is a container and manager for the UI scene under a common Object3D guiRoot.
 * The objects role is to manage the interactions and distribute events to any listeners
 * this is handled by calling `frame` from a browser requestAnimationFrame event.
 *
 * GuiSys also manages the font which is intiialized separately and while a single font
 * is currently defined there is the feasiblity to add support more.
 *
 * GuiSys will also propagate the Opactiy of a UI element up the transform hierarchy,
 * this is the only 'style' that is propagated but it's addition allows a hierarchy of
 * UI elements to by faded in or out based on a root.
 *
 * The sorting of the view elements is customized and handled in frame through the use
 * of the `renderOrder` attribute on the Three.js Object3D. Any object marked as a renderGroup
 * is sorted at a new depth location otherwise objects use their closest parents depth.
 * Order of rendering for objects at the same computed depth is based on pre-traversal order
 */

var DEFAULT_CURSOR_DISTANCE = 2.0;
var DEFAULT_CURSOR_WIDTH = 0.025;
var RENDERSORT_DISTANCE_MULTIPLIER = 64;
var RENDERSORT_DISTANCE_SHIFT = 9;
var DEFAULT_TOUCH_RELEASE_DELAY = 300;

var frameUpdateUID = 0;

/*
 * Creates a guiRoot as a child of the scene root passed in
 */
function GuiSys(root) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  this.root = root;
  this.guiRoot = new _ThreeShim2.default.Object3D();
  this.root.add(this.guiRoot);
  this.lastHit = null;
  this.lastHitType = _GuiSysEvent.GuiSysHitType.GAZE;
  this._lastHitCache = [];
  this.lastHitDistance = null;
  this.isVRPresenting = false;
  this._requestFrames = {};
  // This is a minimum z distance to prevent z-fighting in z-buffer.
  // Todo: We may need to dynamically set this scale depends on the camera.
  this.ZOffsetScale = DEFAULT_Z_OFFSET_SCALE;

  // This is the position mouse input is pointing to in viewport
  this.mouseOffset = null;

  // This defines the styles for mouse cursor in diffrent mouse cursor state
  this.mouseCursorInactiveStyle = 'default';
  this.mouseCursorActiveStyle = 'pointer';
  // This is the current mouse state
  this.mouseCursorActive = false;

  // When user touch leave screen, to keep touch interaction working smoothly,
  // the hit offset should remain in the same place for a period of time before
  // moving it back to gaze cursor.
  this.touchReleaseDelay = DEFAULT_TOUCH_RELEASE_DELAY;

  // If mouse hit not enabled, mouse will not be used to interact with views
  this.mouseHitEnabled = true;
  // If touch hit not enabled, touch will not be used to interact with views
  this.touchHitEnabled = true;

  // If cursor not enabled, it will not appear in the scene.
  this.cursorEnabled = false;
  // Only show the cursor when over an interactable object.
  this.cursorAutoHide = false;
  // Move cursor on top of object underneath instead of using fixed distance.
  this.cursorAutoDepth = true;
  // Distance between camera and cursor; only used when auto-depth is false.
  this.cursorFixedDistance = DEFAULT_CURSOR_DISTANCE;

  // Detect and support older constructor GuiSys(root, font) until fully migrated.
  var p = params && params.material ? { font: params } : params;
  this.font = p.font || (0, _SDFFont.loadFont)();

  // Override default values. Can also call setter methods directly.
  // example params: { 'cursorFixedDistance': 1.5 }
  if (p !== undefined) {
    (0, _UIViewUtil.setParams)(this, p);
  }

  // Event dispatcher to dispatch guisys events
  this.eventDispatcher = new _ThreeShim2.default.EventDispatcher();

  this._inputControls = new _InputControls2.default();
  this._inputControls.addInputSource(new _GamepadInputs2.default());
  this._inputControls.addInputSource(new _KeyboardInputs2.default());
  this._inputControls.addInputSource(new _MouseInputs2.default());
  this._inputControls.addInputSource(new _TouchInputs2.default());

  // Register to events.
  window.addEventListener('vrdisplayactivate', this._onEnterVR.bind(this));
  window.addEventListener('vrdisplaydeactivate', this._onExitVR.bind(this));
  this._inputControls.eventDispatcher.addEventListener('GamepadInputEvent', this._onGamepadEvent.bind(this));
  this._inputControls.eventDispatcher.addEventListener('KeyboardInputEvent', this._onKeyboardEvent.bind(this));
  this._inputControls.eventDispatcher.addEventListener('MouseInputEvent', this._onMouseEvent.bind(this));
  this._inputControls.eventDispatcher.addEventListener('TouchInputEvent', this._onTouchEvent.bind(this));
}

GuiSys.prototype = Object.assign(Object.create(Object.prototype), {

  constructor: GuiSys,

  /**
    * Add a Three.js object as a child of the guiRoot obejct
    */
  add: function add(child) {
    this.guiRoot.add(child);
  },

  /**
    * Remove a Three.js object as a child of the guiRoot object
    * It is the job of the caller to handle deallocation of the object
    */
  remove: function remove(child) {
    this.guiRoot.remove(child);
  },

  /**
    * request for a function to be run on the following frame of the GuiSys
    * first argument for the function is Date.now() as is dependable across browsers
    */
  requestFrameFunction: function requestFrameFunction(func) {
    var uid = frameUpdateUID++;
    this._requestFrames[uid] = func;
    return uid;
  },

  /**
    * cancel for the function associated with the uid
    */
  cancelFrameFunction: function cancelFrameFunction(uid) {
    delete this._requestFrames[uid];
  },

  /**
    * Updates the reorder and propagates the Opacity through the view hierarchy
    */
  frameRenderUpdates: function () {
    function matrixDistance(matrixA, matrixB) {
      var x = matrixA.elements[12] - matrixB.elements[12];
      var y = matrixA.elements[13] - matrixB.elements[13];
      var z = matrixA.elements[14] - matrixB.elements[14];
      return Math.sqrt(x * x + y * x + z * z);
    }
    function applyUpdates(node, currentOpacity, updateContext, index) {
      // a render group is defined as a hierachy of node that are sorted on the same
      // distance key. Children of a rendergroup node are also sorted on the same distance
      // until another group is found
      // within each ground each node is rendered in pre-order
      if (node.renderGroup) {
        // calculate the distance from the camera to origin to node origin
        var dist = matrixDistance(node.matrixWorld, updateContext.camera.matrixWorld);
        index = updateContext.renderOrder;
        // UIViews always draw back to front due the potential of transparency within the background
        if (node.type === 'UIView') {
          dist = Math.max(0, updateContext.camera.far - dist);
        }
        // shift up the by 9 give 512 additional levels for each descretized depth
        updateContext.distances[index] = Math.floor(dist * RENDERSORT_DISTANCE_MULTIPLIER) << RENDERSORT_DISTANCE_SHIFT;
      }

      updateContext.renderOrder++;
      node.renderOrder = updateContext.distances[index] + updateContext.renderOrder;

      if (node.type === 'UIView') {
        currentOpacity *= node.opacity;
        node.applyUpdates(currentOpacity);
      }
      for (var i in node.children) {
        applyUpdates(node.children[i], currentOpacity, updateContext, index);
      }
    }
    return function (camera) {

      var curTime = Date.now();
      var currentRequests = this._requestFrames;
      this._requestFrames = {};
      for (var update in currentRequests) {
        currentRequests[update](curTime);
      }

      var updateContext = {
        camera: camera,
        renderOrder: 0,
        distances: [Math.floor(camera.far * RENDERSORT_DISTANCE_MULTIPLIER) << RENDERSORT_DISTANCE_SHIFT],
        distancesNode: [null]
      };
      // apply hierarchical updates of opacity and determine render order
      applyUpdates(this.root, 1, updateContext, 0);

      // Check if we need to initialize the cursor.
      if (this.cursorEnabled && !this.cursorMesh) {
        this.addCursor();
      }
    };
  }(),

  /**
    * `frameInputEvents` must be called on a requestAnimationFrame event based
    * as this will handle the interactions of the browser devices and
    * headset gaze with the UI elements. Events are created and distributed
    * to any listeners
    */
  frameInputEvents: function () {
    var raycaster = new _ThreeShim2.default.Raycaster();
    return function (camera, renderer) {
      // Raycast from camera, check for intersection with a view.
      var hitInput = this.getHitInput();
      raycaster.setFromCamera(hitInput.hitOffset, camera);
      var hit = raycaster.intersectObject(this.root, true);
      if (hit.length > 0 && hit[0].distance > 0) {
        this.updateLastHit(hit[0].object, hitInput.hitType);
        // Always update distance since object could be moving.
        this.lastHitDistance = hit[0].distance;
      } else {
        this.updateLastHit(null, hitInput.hitType);
      }

      var renderTarget = renderer ? renderer.domElement : null;
      this._inputControls.frame(renderTarget);
      this._updateMouseCursorStyle(renderTarget);
    };
  }(),

  /**
    * `frame` is a helper to call through to frameRenderUpdates and frameInputEvents
    * in the correct order to update GuiSys
    * the calls can be made seperately as required
    */
  frame: function frame(camera, renderer) {
    this.frameRenderUpdates(camera);
    this.frameInputEvents(camera, renderer);
    this.updateCursor(camera);
  },

  /**
    * updates the last hit object and the hierarchy of views
    * creates inetraction events that are then distributed to listeners of GuiSys
    */
  updateLastHit: function updateLastHit(hit, hitType) {
    var hitCache = [];
    var currentHit = hit;

    // First pass of hit views in hierachy
    var hitViews = [];
    while (currentHit) {
      if (currentHit.type === 'UIView') {
        hitViews.push(currentHit);
      }
      currentHit = currentHit.parent;
    }
    // Determine the target of hit event
    // Save those view that accept hit event to hitCache
    var target = null;
    this.mouseCursorActive = false;
    for (var i = hitViews.length - 1; i >= 0; i--) {
      // hitViews are all UIViews so shouldAcceptHitEvent/shouldInterceptHitEvent
      // is never null. Here shouldAcceptHitEvent determine whether this view can
      // be the target of hit event
      if (hitViews[i].shouldAcceptHitEvent()) {
        target = hitViews[i].id;
        hitCache[hitViews[i].id] = hitViews[i];
        if (hitViews[i].isMouseInteractable) {
          // If any view that accept hit event is mouse interactable
          // the mouse cursor state should be active.
          this.mouseCursorActive = true;
        }
      }
      // Here shouldInterceptHitEvent determine whether this view's subviews can be
      // the target of hit event
      if (hitViews[i].shouldInterceptHitEvent()) {
        break;
      }
    }

    // Update last hit
    currentHit = target !== null && hitCache[target] ? hitCache[target] : null;
    if (this.lastHit !== currentHit || this.lastHitType !== hitType) {
      // Emit hit changed event
      this.eventDispatcher.dispatchEvent(new _GuiSysEvent.GuiSysEvent(_GuiSysEvent.GuiSysEventType.HIT_CHANGED, { lastHit: this.lastHit, currentHit: currentHit,
        lastHitType: this.lastHitType, currentHitType: hitType }));
      this.lastHit = currentHit;
      this.lastHitType = hitType;
    }

    // Emit focus lost events
    for (var id in this._lastHitCache) {
      if (!hitCache[id]) {
        this.eventDispatcher.dispatchEvent(new _GuiSysEvent.UIViewEvent(this._lastHitCache[id], _GuiSysEvent.UIViewEventType.FOCUS_LOST, { target: this.lastHit, hitType: this.lastHitType }));
      }
    }
    // Emit focus gained events
    for (var _id in hitCache) {
      if (!this._lastHitCache[_id]) {
        this.eventDispatcher.dispatchEvent(new _GuiSysEvent.UIViewEvent(hitCache[_id], _GuiSysEvent.UIViewEventType.FOCUS_GAINED, { target: this.lastHit, hitType: this.lastHitType }));
      }
    }

    // Update hit cache
    this._lastHitCache = hitCache;
  },

  addCursor: function addCursor() {
    this.cursorMesh = this.makeDefaultCursor();
    this.cursorMesh.raycast = function () {
      return null; // Disable hit/intersection with cursor mesh.
    };
    this.root.add(this.cursorMesh);
    this.cursorMesh.visible = false;

    // Make cursor appear on top of other objects.
    this.cursorMesh.material.depthTest = false;
    this.cursorMesh.material.depthWrite = false;
    this.cursorMesh.renderOrder = 1;
  },

  updateCursor: function updateCursor(camera) {
    // The cursor is placed at fixed distance from camera, unless cursorAutoDepth
    // is enabled and cursor is over a UI object, then we put the cursor at same
    // distance as that object (i.e. lastHitDistance).
    var cursorZ = this.cursorAutoDepth && this.lastHit !== null ? this.lastHitDistance : this.cursorFixedDistance;

    // Update cursor based on global transform of camera. Leave matrixAutoUpdate
    // enabled, since we modify cursorMesh.scale when cursorAutoDepth is used.
    if (this.cursorMesh && this.cursorEnabled) {
      var vector = new _ThreeShim2.default.Vector3(0, 0, -cursorZ);
      vector.applyQuaternion(camera.getWorldQuaternion());
      vector.add(camera.getWorldPosition());
      this.cursorMesh.position.copy(vector);
      this.cursorMesh.rotation.copy(camera.getWorldRotation());

      if (this.cursorAutoDepth) {
        // Scale cursor so it appears same size regardless of depth.
        // TODO: Clamping to a max/min depth.
        var scale = cursorZ;
        this.cursorMesh.scale.set(scale, scale, scale);
      }
    }

    // Update visibility of cursor based on lastHit.
    if (this.cursorMesh) {
      this.cursorMesh.visible = this.cursorEnabled && (!this.cursorAutoHide || this.lastHit !== null && !!this.lastHit.isInteractable) && this.lastHitType === _GuiSysEvent.GuiSysHitType.GAZE;
    }
  },

  makeDefaultCursor: function makeDefaultCursor() {

    var canvas = document.createElement('canvas');
    // Three.js requires textures in powers of 2 (and not fractions).
    canvas.width = 256;
    canvas.height = 256;
    // Draw circle on canvas programatically.
    // TODO: Customize color or change color on hit.
    // TODO: Support image provided by us or by user.
    var ctx = canvas.getContext('2d');
    ctx.beginPath();
    // centerX, centerY, radius, startAngle, endAngle
    ctx.arc(128, 128, 95, 0, 2 * Math.PI);
    // Match UI style guide: white outline 100% opaque, white fill 80% opaque.
    ctx.strokeStyle = 'rgba(256, 256, 256, 1)';
    ctx.fillStyle = 'rgba(256, 256, 256, 0.8)';
    ctx.lineWidth = 25;
    ctx.stroke();
    ctx.fill();
    // Canvas contents will be used for a texture.
    var texture = new _ThreeShim2.default.Texture(canvas);
    texture.needsUpdate = true;
    var material = new _ThreeShim2.default.MeshBasicMaterial({
      transparent: true,
      opacity: 1.0,
      side: _ThreeShim2.default.DoubleSide,
      map: texture
    });
    // scale to 25mm (~1 inches)
    var defaultCursor = new _ThreeShim2.default.Mesh(new _ThreeShim2.default.PlaneGeometry(DEFAULT_CURSOR_WIDTH, DEFAULT_CURSOR_WIDTH), material);
    return defaultCursor;
  },

  _updateMouseCursorStyle: function _updateMouseCursorStyle(renderTarget) {
    var cursorStyle = this.mouseCursorActive ? this.mouseCursorActiveStyle : this.mouseCursorInactiveStyle;
    if (renderTarget && renderTarget.style) {
      renderTarget.style.cursor = cursorStyle;
      renderTarget.style.cursor = '-webkit-' + cursorStyle;
      renderTarget.style.cursor = '-moz-' + cursorStyle;
    }
  },

  getHitInput: function getHitInput() {
    // The hit offset represent the offset of hit ray position on the screen:
    // When in vr mode, there's no mouse input, so set offset to (0, 0) to use gaze direction.
    // When in non-vr mode, there can be mouse input, so offset can be mouse position if mouse input
    // is received.
    var hitType = !this.isVRPresenting && this.mouseOffset ? _GuiSysEvent.GuiSysHitType.MOUSE : _GuiSysEvent.GuiSysHitType.GAZE;
    return {
      hitOffset: hitType === _GuiSysEvent.GuiSysHitType.MOUSE ? this.mouseOffset : new _ThreeShim2.default.Vector2(0, 0),
      hitType: hitType
    };
  },

  _onEnterVR: function _onEnterVR() {
    this.isVRPresenting = true;
  },

  _onExitVR: function _onExitVR() {
    this.isVRPresenting = false;
  },

  _updateMouseOffset: function _updateMouseOffset(x, y) {
    // Any update on mouse offset should cancel the timeout fot
    // getting gaze cursor back
    this._cancelTouchReleaseTimeout();
    // Update the mouse offset
    x = x || 0;
    y = y || 0;
    if (!this.mouseOffset) {
      this.mouseOffset = new _ThreeShim2.default.Vector2(0, 0);
    }
    this.mouseOffset.set(x, y);
  },

  _cancelTouchReleaseTimeout: function _cancelTouchReleaseTimeout() {
    this._touchReleaseDelayTimeout && clearTimeout(this._touchReleaseDelayTimeout);
    this._touchReleaseDelayTimeout = null;
  },
  _dispatchInputEvent: function _dispatchInputEvent(event) {
    // Attach last hit target to the event
    this.eventDispatcher.dispatchEvent(new _GuiSysEvent.GuiSysEvent(_GuiSysEvent.GuiSysEventType.INPUT_EVENT, {
      target: this.lastHit,
      hitType: this.lastHitType,
      inputEvent: event
    }));
  },


  _onGamepadEvent: function _onGamepadEvent(event) {
    // Dispatch GamepadInputEvent
    this._dispatchInputEvent(event);
  },

  _onKeyboardEvent: function _onKeyboardEvent(event) {
    // Dispatch KeyboardInputEvent
    this._dispatchInputEvent(event);
  },

  _onMouseEvent: function _onMouseEvent(event) {
    // Only update mouse offset when mouse hit is enabled
    if (this.mouseHitEnabled) {
      if (event.mouseEventType === 'mousemove') {
        this._updateMouseOffset(event.viewportX, event.viewportY);
      }
    }
    // Dispatch MouseInputEvent
    this._dispatchInputEvent(event);
  },

  _onTouchEvent: function _onTouchEvent(event) {
    var _this = this;

    // Only update mouse offset when touch hit is enabled
    if (this.touchHitEnabled) {
      /*
       * Touch behavior of GuiSys:
       * 1. When touch on the viewport, the touch will take over the gaze cursor
       * 2. When touch leave the viewport, after touchReleaseDelay, the gaze cursor will come back
       */
      var targetTouches = event.targetTouches;
      var hasTargetTouches = targetTouches && targetTouches.length > 0;

      if (hasTargetTouches) {
        this._updateMouseOffset(targetTouches[0].viewportX, targetTouches[0].viewportY);
      } else {
        this._cancelTouchReleaseTimeout();
        this._touchReleaseDelayTimeout = setTimeout(function () {
          _this.mouseOffset = null;
        }, this.touchReleaseDelay);
      }
    }
    // Dispatch TouchInputEvent
    this._dispatchInputEvent(event);
  },

  setFont: function setFont(font) {
    this.font = font;
  },

  /**
    * Sets if mouse hit is enabled
    */
  setMouseHitEnabled: function setMouseHitEnabled(flag) {
    this.mouseHitEnabled = flag;
  },

  /**
    * Customize the mouse cursor style when mouse cursor is inactive
    */
  setMouseCursorInactiveStyle: function setMouseCursorInactiveStyle(style) {
    this.mouseCursorInactiveStyle = style;
  },

  /**
    * Customize the mouse cursor style when mouse cursor is active
    */
  setMouseCursorActiveStyle: function setMouseCursorActiveStyle(style) {
    this.mouseCursorActiveStyle = style;
  },

  /**
    * Sets if touch hit is enabled
    */
  setTouchHitEnabled: function setTouchHitEnabled(flag) {
    this.touchHitEnabled = flag;
  },

  /**
    * Sets if the cursor is displayed
    */
  setCursorEnabled: function setCursorEnabled(flag) {
    this.cursorEnabled = flag;
  },

  /**
    * An autohide cursor will only display when over an interactable ui element
    */
  setCursorAutoHide: function setCursorAutoHide(flag) {
    this.cursorAutoHide = flag;
  },

  /**
    * An autodepth cursor will change distance based on where the interaction occurs
    */
  setCursorAutoDepth: function setCursorAutoDepth(flag) {
    this.cursorAutoDepth = flag;
  },

  /**
    * manual setting of distance of the cursor from the camera
    */
  setCursorFixedDistance: function setCursorFixedDistance(distance) {
    this.cursorFixedDistance = distance;
  }
});
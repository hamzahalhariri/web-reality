/*
 * Copyright (c) 2016-present, Oculus, LLC
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FourByFourRectGeometry = FourByFourRectGeometry;

var _ThreeShim = require('../ThreeShim');

var _ThreeShim2 = _interopRequireDefault(_ThreeShim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BORDER_LEFT = 0; /*
                      * Copyright (c) 2016-present, Oculus, LLC
                      * All rights reserved.
                      *
                      * This source code is licensed under the license found in the LICENSE file in
                      * the root directory of this source tree.
                      */

var BORDER_TOP = 1;
var BORDER_RIGHT = 2;
var BORDER_BOTTOM = 3;

// Helper function to get uv for position in nine-piece stretchy textures
function uvWithInset(pos, inset, insetSize, direction) {
  // Direction: 0 for left to right, 1 for top to bottom
  var splitPos1 = insetSize[direction];
  var splitPos2 = insetSize[direction + 2];
  var splitUV1 = inset[direction];
  var splitUV2 = inset[direction + 2];
  if (pos < splitPos1) {
    return pos / splitPos1 * splitUV1;
  }
  if (1 - pos < splitPos2) {
    return 1 - (1 - pos) / splitPos2 * splitUV2;
  }
  if (1 - splitPos2 === splitPos1) {
    return splitUV1;
  }
  return (pos - splitPos1) / (1 - splitPos2 - splitPos1) * (1 - splitUV2 - splitUV1) + splitUV1;
}

// Defines FourByFourRectGeometry, which works in place of THREE.BufferGeometry, usable in mesh.
// Supports nine-piece stretchy textures, resulting in four corners/four sides image.Used by UIView.js

function FourByFourRectGeometry(dims, border, cropUV, materialIndex) {
  _ThreeShim2.default.BufferGeometry.apply(this);

  dims = dims || [1, 1];
  cropUV = cropUV || [0, 0, 1, 1];
  var texture = border && border.texture || [0, 0, 0, 0];
  var factor = border && border.factor || [0, 0, 0, 0];
  var cssBorderWidth = border && border.cssBorderWidth || 0;
  var originalDim = border.originalDim || dims;

  // limit css border width, see CSSBorderGeometry
  cssBorderWidth = Math.min(Math.min(originalDim[0] / 2, originalDim[1] / 2), cssBorderWidth);

  var vertsX = 0;
  var vertsY = 0;
  var vertUVX = [0.0, 0.0, 0.0, 0.0];
  var vertUVY = [1.0, 0.0, 0.0, 0.0];
  var vertPosX = [0.0, 0.0, 0.0, 0.0];
  var vertPosY = [0.0, 0.0, 0.0, 0.0];

  var cssCropX = dims[0] > 0 ? Math.max(cssBorderWidth - (originalDim[0] - dims[0]) / 2, 0) / dims[0] : 0;
  var cssCropY = dims[1] > 0 ? Math.max(cssBorderWidth - (originalDim[1] - dims[1]) / 2, 0) / dims[1] : 0;
  var cssCrop = [cssCropX, cssCropY, cssCropX, cssCropY];

  // Here we crop the geometry by the css border. To keep the nine-piece stretchy
  // after cropped, the approach here is:
  // 1. The positions of the edges of the cropped rectangle are defined by cssCrop
  // We need to calculate their uvs in nine-piece stretchy texture using uvWithInset
  // 2. The positions and uvs of the inner sides are fixed, but we need to judge if
  // they are inside the cropped rectangle

  // x components
  vertPosX[vertsX] = cssCrop[BORDER_LEFT];
  vertUVX[vertsX++] = uvWithInset(cssCrop[BORDER_LEFT], texture, factor, 0);

  if (texture[BORDER_LEFT] > 0.0 && factor[BORDER_LEFT] > cssCrop[BORDER_LEFT] && factor[BORDER_LEFT] < 1 - cssCrop[BORDER_RIGHT]) {
    vertPosX[vertsX] = factor[BORDER_LEFT];
    vertUVX[vertsX++] = texture[BORDER_LEFT];
  }

  if (texture[BORDER_RIGHT] > 0.0 && factor[BORDER_RIGHT] > cssCrop[BORDER_RIGHT] && factor[BORDER_RIGHT] < 1 - cssCrop[BORDER_LEFT]) {
    vertPosX[vertsX] = 1.0 - factor[BORDER_RIGHT];
    vertUVX[vertsX++] = 1.0 - texture[BORDER_RIGHT];
  }

  vertPosX[vertsX] = 1.0 - cssCrop[BORDER_RIGHT];
  vertUVX[vertsX++] = uvWithInset(1.0 - cssCrop[BORDER_RIGHT], texture, factor, 0);

  // y components
  vertPosY[vertsY] = cssCrop[BORDER_TOP];
  vertUVY[vertsY++] = uvWithInset(cssCrop[BORDER_TOP], texture, factor, 1);

  if (texture[BORDER_TOP] > 0.0 && factor[BORDER_TOP] > cssCrop[BORDER_TOP] && factor[BORDER_TOP] < 1 - cssCrop[BORDER_BOTTOM]) {
    vertPosY[vertsY] = factor[BORDER_TOP];
    vertUVY[vertsY++] = texture[BORDER_TOP];
  }

  if (texture[BORDER_BOTTOM] > 0.0 && factor[BORDER_BOTTOM] > cssCrop[BORDER_BOTTOM] && factor[BORDER_BOTTOM] < 1 - cssCrop[BORDER_TOP]) {
    vertPosY[vertsY] = 1.0 - factor[BORDER_BOTTOM];
    vertUVY[vertsY++] = 1.0 - texture[BORDER_BOTTOM];
  }

  vertPosY[vertsY] = 1.0 - cssCrop[BORDER_BOTTOM];
  vertUVY[vertsY++] = uvWithInset(1.0 - cssCrop[BORDER_BOTTOM], texture, factor, 1);

  for (var i = 0; i < vertsX; i++) {
    vertUVX[i] = (cropUV[2] - cropUV[0]) * vertUVX[i] + cropUV[0];
  }

  for (var _i = 0; _i < vertsY; _i++) {
    vertUVY[_i] = (cropUV[3] - cropUV[1]) * vertUVY[_i] + cropUV[1];
  }

  // create the vertices
  var vertexCount = vertsX * vertsY;
  var horizontal = vertsX - 1;
  var vertical = vertsY - 1;

  var positions = new Float32Array(vertexCount * 3);
  var uv0 = new Float32Array(vertexCount * 2);

  for (var y = 0; y <= vertical; y++) {
    var yPos = -(-1 + vertPosY[y] * 2) * (dims[1] * 0.5);
    var uvY = 1.0 - vertUVY[y];

    for (var x = 0; x <= horizontal; x++) {
      var _index = y * (horizontal + 1) + x;
      positions[_index * 3 + 0] = (-1 + vertPosX[x] * 2) * (dims[0] * 0.5);
      positions[_index * 3 + 1] = yPos;
      positions[_index * 3 + 2] = 0;
      uv0[_index * 2 + 0] = vertUVX[x];
      uv0[_index * 2 + 1] = uvY;
    }
  }

  var indices = new Uint32Array(horizontal * vertical * 6);
  var index = 0;
  for (var _y = 0; _y < vertical; _y++) {
    for (var _x = 0; _x < horizontal; _x++) {
      indices[index + 0] = _y * (horizontal + 1) + _x;
      indices[index + 1] = _y * (horizontal + 1) + _x + 1;
      indices[index + 2] = (_y + 1) * (horizontal + 1) + _x;
      indices[index + 3] = (_y + 1) * (horizontal + 1) + _x;
      indices[index + 4] = _y * (horizontal + 1) + _x + 1;
      indices[index + 5] = (_y + 1) * (horizontal + 1) + _x + 1;
      index += 6;
    }
  }

  this.addAttribute('position', new _ThreeShim2.default.BufferAttribute(positions, 3));
  this.addAttribute('uv', new _ThreeShim2.default.BufferAttribute(uv0, 2));
  this.addGroup(0, horizontal * vertical * 6, materialIndex);
  this.setIndex(new _ThreeShim2.default.BufferAttribute(indices, 1));
  this.computeBoundingSphere();
}

FourByFourRectGeometry.prototype = Object.create(_ThreeShim2.default.BufferGeometry.prototype);
FourByFourRectGeometry.prototype.constructor = FourByFourRectGeometry;
/*
 * Copyright (c) 2016-present, Oculus, LLC
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MergedBufferGeometry = MergedBufferGeometry;

var _ThreeShim = require('../ThreeShim');

var _ThreeShim2 = _interopRequireDefault(_ThreeShim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Defines MergedBufferGeometry, which merges different BufferGeometry into one BufferGeometry
function MergedBufferGeometry(geometries) {
  _ThreeShim2.default.BufferGeometry.apply(this);

  if (!geometries) {
    console.warn('THREE.MergedBufferGeometry: empty geometries');
    return;
  }

  // initial attributes
  var vertexCounts = [];
  var vertexOffsets = [];
  var indexOffsets = [];
  var indexCount = 0;
  var vertexCount = 0;
  var attributeDefs = {};
  for (var i = 0; i < geometries.length; i++) {
    var geometry = geometries[i];
    vertexOffsets.push(vertexCount);
    vertexCounts.push(0);
    indexOffsets.push(indexCount);
    indexCount += geometry.index.count;
    var attributes = geometry.attributes;
    for (var key in attributes) {
      var arrayType = attributes[key].array.constructor.name;
      if (!attributeDefs[key]) {
        attributeDefs[key] = {
          itemSize: attributes[key].itemSize,
          arrayType: arrayType,
          arrayConstructror: attributes[key].array.constructor
        };
      } else {
        if (attributeDefs[key].itemSize !== attributes[key].itemSize || attributeDefs[key].arrayType !== arrayType) {
          console.error('THREE.MergedBufferGeometry: cannot merge Geometries that attributes have different definition.');
          return;
        }
      }
      vertexCounts[i] = Math.max(vertexCounts[i], attributes[key].count);
    }
    vertexCount += vertexCounts[i];
  }

  for (var _key in attributeDefs) {
    var initialAttributes = new attributeDefs[_key].arrayConstructror(vertexCount * attributeDefs[_key].itemSize);
    this.addAttribute(_key, new _ThreeShim2.default.BufferAttribute(initialAttributes, attributeDefs[_key].itemSize));
  }

  // merge attributes, index, groups
  var initialIndices = new Uint32Array(indexCount);
  this.setIndex(new _ThreeShim2.default.BufferAttribute(initialIndices, 1));
  for (var _i = 0; _i < geometries.length; _i++) {
    var _geometry = geometries[_i];
    // merge attributes
    this.merge(_geometry, vertexOffsets[_i]);
    // merge indices
    for (var j = 0, count = _geometry.index.count; j < count; j++) {
      this.index.array[indexOffsets[_i] + j] = _geometry.index.array[j] + vertexOffsets[_i];
    }
    // merge groups
    var groups = _geometry.groups;
    for (var _j = 0; _j < groups.length; _j++) {
      var group = groups[_j];
      this.addGroup(group.start + indexOffsets[_i], group.count, group.materialIndex);
    }
  }

  this.computeBoundingSphere();
} /*
   * Copyright (c) 2016-present, Oculus, LLC
   * All rights reserved.
   *
   * This source code is licensed under the license found in the LICENSE file in
   * the root directory of this source tree.
   */

MergedBufferGeometry.prototype = Object.create(_ThreeShim2.default.BufferGeometry.prototype);
MergedBufferGeometry.prototype.constructor = MergedBufferGeometry;
/*
 * Copyright (c) 2016-present, Oculus, LLC
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CSSBorderGeometry = CSSBorderGeometry;

var _ThreeShim = require('../ThreeShim');

var _ThreeShim2 = _interopRequireDefault(_ThreeShim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EPSILON = 1e-10; /*
                      * Copyright (c) 2016-present, Oculus, LLC
                      * All rights reserved.
                      *
                      * This source code is licensed under the license found in the LICENSE file in
                      * the root directory of this source tree.
                      */

var CORNER_COUNT = 4;
var CONTROL_COUNT = 8;

// Helper functions for generating geometry
function sameVertex(x, y, xArray, yArray, index) {
  var oldX = xArray.length > index ? xArray[index] : undefined;
  var oldY = yArray.length > index ? yArray[index] : undefined;
  return oldX !== undefined && oldY !== undefined && Math.abs(x - oldX) < EPSILON && Math.abs(y - oldY) < EPSILON;
}

function pushNewVertex(x, y, xArray, yArray, indexArray) {
  if (!sameVertex(x, y, xArray, yArray, xArray.length - 1)) {
    xArray.push(x);
    yArray.push(y);
  }
  indexArray.push(xArray.length - 1);
}

function mergeLoop(xArray, yArray, indexArray) {
  var lastIndex = xArray.length - 1;
  if (xArray.length > 1 && yArray.length > 1 && sameVertex(xArray[0], yArray[0], xArray, yArray, lastIndex)) {
    for (var i = indexArray.length - 1; i >= 0 && indexArray[i] === lastIndex; i--) {
      indexArray[i] = 0;
    }
    xArray.pop();
    yArray.pop();
  }
}

function triangleCount(value) {
  return value > 1 ? value : 0;
}

/** Defines CSSBorderGeometry, which works in place of THREE.BufferGeometry, usable in mesh.
 *  CSSBorderGeometry supports a bordered view, resulting in four corners/four sides and one background.
 *  Used by UIView.js as background.
 *  The borderRaius/corner sequence is:
 *    1 0
 *    2 3
 *  The control point sequence is:
 *    2 1
 *  3     0
 *  4     7
 *    5 6
 */
function CSSBorderGeometry(dims, borderWidth, borderRadius, cornerTessellationSize, zOffset, borderMaterialIndex, backgroundMaterialIndex) {
  _ThreeShim2.default.BufferGeometry.apply(this);

  dims = dims || [1, 1];
  var maxWidth = Math.min(dims[0] / 2, dims[1] / 2);

  // limit border width and border radius
  borderWidth = Math.min(maxWidth, borderWidth || 0);
  borderRadius = borderRadius || [0, 0, 0, 0];
  for (var i = 0; i < CORNER_COUNT; i++) {
    borderRadius[i] = Math.min(maxWidth, borderRadius[i]);
  }

  // Calculate the indent, indent split the border into 4 sides and 4 corners
  var indentX = [];
  var indentY = [];
  for (var _i = 0; _i < CORNER_COUNT; _i++) {
    indentX.push(Math.max(borderWidth, borderRadius[_i]));
    indentY.push(Math.max(borderWidth, borderRadius[_i]));
  }
  // Center point for corners
  var centerX = [dims[0] - borderRadius[0], borderRadius[1], borderRadius[2], dims[0] - borderRadius[3]];
  var centerY = [dims[1] - borderRadius[0], dims[1] - borderRadius[1], borderRadius[2], borderRadius[3]];

  // Control point for sides
  // 8 outer control points for outbound and 8 inner control points for inner bound
  var outerControlPosX = [dims[0], dims[0] - indentX[0], indentX[1], 0, 0, indentX[2], dims[0] - indentX[3], dims[0]];
  var outerControlPosY = [dims[1] - indentY[0], dims[1], dims[1], dims[1] - indentY[1], indentY[2], 0, 0, indentY[3]];
  var innerControlPosX = [].concat(outerControlPosX);
  innerControlPosX[0] -= borderWidth;
  innerControlPosX[7] -= borderWidth;
  innerControlPosX[3] += borderWidth;
  innerControlPosX[4] += borderWidth;
  var innerControlPosY = [].concat(outerControlPosY);
  innerControlPosY[1] -= borderWidth;
  innerControlPosY[2] -= borderWidth;
  innerControlPosY[5] += borderWidth;
  innerControlPosY[6] += borderWidth;

  // Control point for corner
  var cornerControlPosX = [dims[0], dims[0] - borderRadius[0], borderRadius[1], 0, 0, borderRadius[2], dims[0] - borderRadius[3], dims[0]];
  var cornerControlPosY = [dims[1] - borderRadius[0], dims[1], dims[1], dims[1] - borderRadius[1], borderRadius[2], 0, 0, borderRadius[3]];

  var outerVertPosX = [];
  var outerVertPosY = [];
  var outerIndices = [];

  var innerVertPosX = [];
  var innerVertPosY = [];
  var innerIndices = [];

  // Generate the vertices of the boarder as a ring-trip
  for (var _i2 = 0; _i2 < CORNER_COUNT; _i2++) {
    // generate corner vertices
    {
      var radius = borderRadius[_i2];
      var begin = _i2 * 2;
      var end = _i2 * 2 + 1;
      var arcAngle = Math.PI * 0.5;
      var angleOffset = _i2 * Math.PI * 0.5;
      var innerRadius = radius - borderWidth;

      pushNewVertex(cornerControlPosX[begin], cornerControlPosY[begin], outerVertPosX, outerVertPosY, outerIndices);
      pushNewVertex(innerControlPosX[begin], innerControlPosY[begin], innerVertPosX, innerVertPosY, innerIndices);
      // Do tessellation between corner control points
      var tessellation = Math.ceil(radius * arcAngle / cornerTessellationSize);
      if (tessellation > 0) {
        var deltaAngle = arcAngle / tessellation;
        var theta = 0;
        for (var j = 0; j < tessellation; j++) {
          theta += deltaAngle;
          var angle = angleOffset + theta;
          pushNewVertex(centerX[_i2] + Math.cos(angle) * radius, centerY[_i2] + Math.sin(angle) * radius, outerVertPosX, outerVertPosY, outerIndices);
          if (innerRadius > 0) {
            pushNewVertex(centerX[_i2] + Math.cos(angle) * innerRadius, centerY[_i2] + Math.sin(angle) * innerRadius, innerVertPosX, innerVertPosY, innerIndices);
          } else {
            pushNewVertex(innerControlPosX[begin], innerControlPosY[begin], innerVertPosX, innerVertPosY, innerIndices);
          }
        }
      }
      pushNewVertex(cornerControlPosX[end], cornerControlPosY[end], outerVertPosX, outerVertPosY, outerIndices);
      pushNewVertex(innerControlPosX[end], innerControlPosY[end], innerVertPosX, innerVertPosY, innerIndices);
    }
    // generate side vertices
    {
      var _begin = _i2 * 2 + 1;
      var _end = (_i2 * 2 + 2) % CONTROL_COUNT;
      pushNewVertex(outerControlPosX[_begin], outerControlPosY[_begin], outerVertPosX, outerVertPosY, outerIndices);
      pushNewVertex(innerControlPosX[_begin], innerControlPosY[_begin], innerVertPosX, innerVertPosY, innerIndices);
      pushNewVertex(outerControlPosX[_end], outerControlPosY[_end], outerVertPosX, outerVertPosY, outerIndices);
      pushNewVertex(innerControlPosX[_end], innerControlPosY[_end], innerVertPosX, innerVertPosY, innerIndices);
    }
  }
  mergeLoop(outerVertPosX, outerVertPosY, outerIndices);
  mergeLoop(innerVertPosX, innerVertPosY, innerIndices);

  // create the vertices
  var vertexCount = outerVertPosX.length + innerVertPosX.length;
  var positions = new Float32Array(vertexCount * 3);
  var uv0 = new Float32Array(vertexCount * 2);
  var innerIndexOffset = outerVertPosX.length;

  for (var _i3 = 0; _i3 <= outerVertPosX.length; _i3++) {
    var _index = _i3;
    positions[_index * 3 + 0] = outerVertPosX[_index] - dims[0] * 0.5;
    positions[_index * 3 + 1] = outerVertPosY[_index] - dims[1] * 0.5;
    positions[_index * 3 + 2] = zOffset;
    uv0[_index * 2 + 0] = 0;
    uv0[_index * 2 + 1] = 0;
  }
  for (var _i4 = 0; _i4 <= innerVertPosX.length; _i4++) {
    var _index2 = innerIndexOffset + _i4;
    positions[_index2 * 3 + 0] = innerVertPosX[_i4] - dims[0] * 0.5;
    positions[_index2 * 3 + 1] = innerVertPosY[_i4] - dims[1] * 0.5;
    positions[_index2 * 3 + 2] = zOffset;
    uv0[_index2 * 2 + 0] = 0;
    uv0[_index2 * 2 + 1] = 0;
  }

  var borderIndicesCount = borderWidth > 0 ? 3 * (triangleCount(outerVertPosX.length) + triangleCount(innerVertPosX.length)) : 0;
  var backgroundIndicesCount = 3 * Math.max(0, innerVertPosX.length - 2);
  var indices = new Uint32Array(borderIndicesCount + backgroundIndicesCount);
  var index = 0;
  // Triangles for border
  if (borderWidth > 0) {
    for (var _i5 = 0; _i5 < outerIndices.length; _i5++) {
      var _begin2 = _i5;
      var _end2 = (_i5 + 1) % outerIndices.length;
      if (outerIndices[_begin2] !== outerIndices[_end2]) {
        indices[index + 0] = outerIndices[_begin2];
        indices[index + 1] = outerIndices[_end2];
        indices[index + 2] = innerIndexOffset + innerIndices[_begin2];
        index += 3;
      }
      if (innerIndices[_begin2] !== innerIndices[_end2]) {
        indices[index + 0] = outerIndices[_end2];
        indices[index + 1] = innerIndexOffset + innerIndices[_end2];
        indices[index + 2] = innerIndexOffset + innerIndices[_begin2];
        index += 3;
      }
    }
  }
  // Triangles to fill the background
  for (var _i6 = 1, l = innerVertPosX.length - 1; _i6 < l; _i6++) {
    indices[index + 0] = innerIndexOffset + 0;
    indices[index + 1] = innerIndexOffset + _i6;
    indices[index + 2] = innerIndexOffset + _i6 + 1;
    index += 3;
  }

  this.addAttribute('position', new _ThreeShim2.default.BufferAttribute(positions, 3));
  this.addAttribute('uv', new _ThreeShim2.default.BufferAttribute(uv0, 2));
  this.addGroup(0, borderIndicesCount, borderMaterialIndex);
  this.addGroup(borderIndicesCount, backgroundIndicesCount, backgroundMaterialIndex);
  this.setIndex(new _ThreeShim2.default.BufferAttribute(indices, 1));
  this.computeBoundingSphere();
}

CSSBorderGeometry.prototype = Object.create(_ThreeShim2.default.BufferGeometry.prototype);
CSSBorderGeometry.prototype.constructor = CSSBorderGeometry;
/*
 * Copyright (c) 2016-present, Oculus, LLC
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2016-present, Oculus, LLC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This source code is licensed under the license found in the LICENSE file in
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * the root directory of this source tree.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _ThreeShim = require('../ThreeShim');

var _ThreeShim2 = _interopRequireDefault(_ThreeShim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var touchEvents = ['touchstart', 'touchend', 'touchmove', 'touchcancel', 'touchenter', 'touchleave'];

/**
 * Basic wrapper of touch events, which can dispatch TouchInputEvent
 */

var TouchInputs = function () {
  function TouchInputs() {
    _classCallCheck(this, TouchInputs);

    this.eventDispatcher = new _ThreeShim2.default.EventDispatcher();
    this.inputEventType = 'TouchInputEvent';
    this.viewport = null;

    this.currentTarget = null;
    this._onTouchEvent = this._onTouchEvent.bind(this);
  }

  _createClass(TouchInputs, [{
    key: 'generateVRTouchList',
    value: function generateVRTouchList(touchlist, viewport) {
      var vrTouchList = [];
      // The order of touchlist vary already across implementations.
      // Here's the specs we can rely on:
      // 1. Each touch has its unique identifier.
      // 2. The first element of touch list is the primary touch in common case
      for (var i = 0; i < touchlist.length; i++) {
        var touch = touchlist[i];
        var viewportX = (touch.clientX - viewport.left) / viewport.width * 2 - 1;
        var viewportY = -((touch.clientY - viewport.top) / viewport.height) * 2 + 1;
        // Only pass those needed properties in WebVR
        // Ignore screenX/screenY, clientX/clientY, offsetX/offsetY which are not used in vr.
        // Add viewportX, viewportY instead.
        // Ignore experimental touch area properties
        vrTouchList.push({
          identifier: touch.identifier,
          viewportX: viewportX,
          viewportY: viewportY,
          target: touch.target
        });
      }
      return vrTouchList;
    }
  }, {
    key: 'generateInputEvent',
    value: function generateInputEvent(event) {
      // Only pass those needed properties in WebVR
      var viewport = event.currentTarget.getBoundingClientRect();
      return {
        type: this.inputEventType,
        touchEventType: event.type,
        changedTouches: this.generateVRTouchList(event.changedTouches, viewport),
        targetTouches: this.generateVRTouchList(event.targetTouches, viewport),
        touches: this.generateVRTouchList(event.touches, viewport),
        altKey: event.altKey,
        ctrlKey: event.ctrlKey,
        metaKey: event.metaKey,
        shiftKey: event.shiftKey
      };
    }
  }, {
    key: '_onTouchEvent',
    value: function _onTouchEvent(event) {
      // Prevent browser from converting touch event to mouse event
      event.preventDefault();

      // Check and make sure event target is current target
      if (event.currentTarget && event.currentTarget === this.currentTarget) {
        this.eventDispatcher.dispatchEvent(this.generateInputEvent(event));
      }
    }
  }, {
    key: 'frame',
    value: function frame(targetElement) {
      // If current render target changed
      if (targetElement && this.currentTarget !== targetElement) {
        // Unregister previous event listeners
        if (this.currentTarget) {
          for (var i = 0; i < touchEvents.length; i++) {
            this.currentTarget.removeEventListener(touchEvents[i], this._onTouchEvent, true);
          }
        }
        this.currentTarget = targetElement;
        // Register event listeners
        if (this.currentTarget) {
          for (var _i = 0; _i < touchEvents.length; _i++) {
            this.currentTarget.addEventListener(touchEvents[_i], this._onTouchEvent, true);
          }
        }
      }
    }
  }]);

  return TouchInputs;
}();

exports.default = TouchInputs;
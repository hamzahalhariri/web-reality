/*
 * Copyright (c) 2016-present, Oculus, LLC
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

/**
 * The source using AudioBufferSourceNode
 */

export default function VRAudioBufferSource(vrAudioContext) {
  this._vrAudioContext = vrAudioContext;
}

VRAudioBufferSource.prototype = Object.assign( Object.create( Object.prototype ), {
  constructor: VRAudioBufferSource,

  initializeAudio: function(url) {
    this.url = url;
    var xhr = new XMLHttpRequest();
    xhr.open('GET', this.url);
    xhr.responseType = 'arraybuffer';

    const self = this;
    xhr.onload = function () {
      if (xhr.status === 200) {
        self._vrAudioContext.getWebAudioContext().decodeAudioData(xhr.response,
          function (buffer) {
            self._buffer = buffer;
            self._onMediaReady();
          },
          function (message) {
            console.log('[VRAudioBufferSource] Decoding failure: ' + self.url + ' (' + message + ')');
          });
      } else {
        console.log('[VRAudioBufferSource] XHR Error: ' + self.url + ' (' + xhr.statusText + ')');
      }
    };

    xhr.onerror = function (event) {
      console.log('[VRAudioBufferSource] XHR Network failure: ' + self.url);
    };

    xhr.send();
  },

  getSourceNode: function() {
    return this._sourceNode;
  },

  _onMediaReady: function() {
    this.onMediaReady && this.onMediaReady();
  },

  _onMediaEnded: function() {
    this.onMediaEnded && this.onMediaEnded();
  },

  play: function() {
    // Every time play a buffered audio, a new buffer source node need to be created
    this.stop();
    this._sourceNode = this._vrAudioContext.getWebAudioContext().createBufferSource();
    this._sourceNode.onended = this._onMediaEnded.bind(this);
    this._sourceNode.buffer = this._buffer;
    this._sourceNode.start();
  },

  stop: function() {
    if (this._sourceNode) {
      this._sourceNode.stop();
      this._sourceNode.disconnect();
      this._sourceNode = undefined;
    }
  },

  dispose: function() {
    this.stop();
    this.onMediaReady = undefined;
    this.onMediaEnded = undefined;
  },

});
